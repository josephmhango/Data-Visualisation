{
  "hash": "dc0951c80e61af529b1ca21954cefca4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"From ggplot2 to Python: Transferable Grammar-of-Graphics & Dashboard Skills\"\nsubtitle: \"Data Visualisation — Cross-platform thinking\"\nauthor: \"Harper Adams University\"\ncss: scroll.css\nformat:\n  revealjs:\n    theme: simple\n    slide-number: true\n    preview-links: true\n    incremental: false\n    transition: fade\n    code-fold: true\n    code-line-numbers: true\n    highlight-style: github\nexecute:\n  echo: true\n  warning: false\n  message: false\n  freeze: auto\nparams:\n  python: 'C:/ProgramData/anaconda3/python.exe'\n---\n\n\n\n## Where you are\n\nYou already know how to:\n\n- Think in the **Grammar of Graphics**\n- Build clear, honest plots with **ggplot2**\n- Assemble dashboards with **Quarto**\n\nToday: **prove to yourself those skills transfer**.\n\n**Goal:** leave with a mental model that survives tool changes.\n\n---\n\n## The take-home message\n\nTools change. Principles don’t.\n\n- ggplot2 is one *implementation* of a deeper idea.\n- Python has **multiple plotting cultures**:\n  - some align with the grammar-of-graphics\n  - others deviate\n\nIf you understand the *conceptual layers*, you can work anywhere.\n\n---\n\n## Roadmap\n\n1. Transfer the **grammar-of-graphics** mindset to Python\n2. Where Python practice **deviates**\n3. “Translation enablers”\n4. Dashboards: transferring **Quarto dashboard thinking** to:\n   - Streamlit\n   - Plotly Dash\n   - Bokeh\n\n---\n\n## Grammar of Graphics: the mental model\n\nA plot is built from:\n\n- **Data**\n- **Aesthetics:** mappings from variables → visual channels\n- **Geoms:** marks\n- **Stats:** transformations\n- **Scales:** map data units → visual units\n- **Coordinates**\n- **Facets**\n- **Theme / guides / annotations**\n\nggplot2 makes these layers explicit.\n\n---\n\n## Why the model is transferable\n\nBecause most plotting systems must answer the same questions:\n\n- What is the dataset?\n- Which columns control x / y / color / size?\n- What geometry is being drawn?\n- How are data transformed?\n- What scales and guides are shown?\n- How do we handle multiple panels?\n\nDifferent libraries expose these answers differently.\n\n---\n\n## Transfer skills checklist\n\nWhen you open a *new plotting tool*, ask:\n\n1. How do I specify **data + mappings**?\n2. How do I add **marks/geoms**?\n3. What is “stat” called here?\n4. How do I control **scales, legends, themes**?\n5. What’s the idiom for **faceting**?\n6. What’s the default *philosophy*?\n\n---\n\n## The Python landscape\n\n- **Matplotlib**: imperative, “draw on axes”\n- **Seaborn**: statistical defaults; high-level wrappers\n- **Plotly**: declarative + interactive; “figure as a spec”\n- **Grammar-aligned tools**\n  - **plotnine**\n  - **seaborn objects**\n  - **plotly express**\n\nPython isn’t “one way” — it’s multiple ecosystems.\n\n---\n\n## A single dataset for comparisons\n\nWhen practising, use the same data in R and Python.\n\n\n\n\n\n\n\n\n\n\n\n---\n\n## ggplot2 baseline\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(peng, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n  geom_point() +\n  facet_wrap(~ sex) +\n  labs(\n    title = \"Penguins: bill length vs bill depth\",\n    x = \"Bill length\",\n    y = \"Bill depth\",\n    color = \"Species\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](transferrability_files/figure-revealjs/ggplot-baseline-1.png){fig-align='center' width=100% height=85vh}\n:::\n:::\n\n\n\n---\n\n## What exactly did you just do?\n\nYou declared:\n\n- data: `peng`\n- aes: x, y, color\n- geom: point\n- facet: by sex\n- labels + theme\n\nNow we’ll reproduce the *same conceptual plot* in Python, multiple ways.\n\n---\n\n## Option A: plotnine\n\n**plotnine** is intentionally ggplot-like.\n\n> Strength: minimal mental translation  \n> Weakness: not the default Python culture; ecosystem integration varies\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_point, facet_wrap, labs, theme_minimal\n\n# peng should be a pandas DataFrame in Python.\n# If you want this to run inside Quarto, you can export peng from R to CSV\n# and read it in Python.\n\n(\n  ggplot(peng, aes(\"bill_length_mm\", \"bill_depth_mm\", color=\"species\"))\n  + geom_point()\n  + facet_wrap(\"~sex\")\n  + labs(\n      title=\"Penguins: bill length vs bill depth\",\n      x=\"Bill length\",\n      y=\"Bill depth\",\n      color=\"Species\",\n    )\n  + theme_minimal()\n)\n```\n:::\n\n\n\n---\n\n## Option B: seaborn objects\n\nSeaborn has a newer “objects” interface that is **more declarative**.\n\n> Strength: grammar-like + modern seaborn  \n> Weakness: still evolving; not everyone uses it yet\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport seaborn.objects as so\n\n(\n  so.Plot(peng, x=\"bill_length_mm\", y=\"bill_depth_mm\", color=\"species\")\n    .add(so.Dots())\n    .facet(col=\"sex\")\n    .label(\n      title=\"Penguins: bill length vs bill depth\",\n      x=\"Bill length\",\n      y=\"Bill depth\",\n      color=\"Species\",\n    )\n)\n```\n:::\n\n\n\n---\n\n## Option C: Plotly Express\n\nPlotly Express is “one function → one figure spec”.\n\n> Strength: interactivity, quick faceting, easy share  \n> Weakness: theming + fine control can shift you into lower-level Plotly\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport plotly.express as px\n\nfig = px.scatter(\n  peng,\n  x=\"bill_length_mm\",\n  y=\"bill_depth_mm\",\n  color=\"species\",\n  facet_col=\"sex\",\n  title=\"Penguins: bill length vs bill depth\",\n  labels={\n    \"bill_length_mm\": \"Bill length\",\n    \"bill_depth_mm\": \"Bill depth\",\n    \"species\": \"Species\",\n    \"sex\": \"Sex\",\n  },\n)\nfig.show()\n```\n:::\n\n\n\n---\n\n## What’s “grammar-like” about these?\n\nThey let you specify:\n\n- data + mappings\n- mark type\n- facets\n- guides\n\nYou’re still thinking in layers, even if the syntax differs.\n\n---\n\n## Matplotlib: the imperative tradition\n\nMatplotlib often feels like:\n\n- create figure/axes\n- draw each thing\n- manually manage legend, labels, scales, faceting\n\nThis is not “bad” — it’s powerful and explicit — but it’s a different *cognitive style*.\n\n---\n\n## Matplotlib version of the same idea\n\nNotice how the “grammar pieces” are now scattered across steps.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 2, figsize=(10, 4), sharex=True, sharey=True)\n\nfor sex, ax in zip([\"female\", \"male\"], axes):\n    df_sex = peng[peng[\"sex\"] == sex]\n    for sp, df_sp in df_sex.groupby(\"species\"):\n        ax.scatter(df_sp[\"bill_length_mm\"], df_sp[\"bill_depth_mm\"], label=sp, alpha=0.8)\n    ax.set_title(sex.title())\n\nfig.suptitle(\"Penguins: bill length vs bill depth\", y=1.02)\nfig.supxlabel(\"Bill length\")\nfig.supylabel(\"Bill depth\")\naxes[1].legend(title=\"Species\", bbox_to_anchor=(1.02, 1), loc=\"upper left\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output-display}\n![](transferrability_files/figure-revealjs/py-matplotlib-1.png){width=100%}\n:::\n:::\n\n\n\n---\n\n## What changed?\n\nIn ggplot2, the “specification” *is* the plot.\n\nIn matplotlib, the plot is the **result of a procedure**.\n\nConsequences:\n\n- Faceting becomes “make subplots and loop”\n- Legends and scales often require manual attention\n- Reusable styles/themes are possible, but not the default mental model\n\n---\n\n## Seaborn classic interface: convenient, but layered differently\n\nClassic seaborn often bundles:\n\n- a mark + statistical transformation + defaults  \ninto one function call\n\nGood for speed, but it can hide the “stat layer”.\n\n---\n\n## Example: smoothing/regression defaults\n\nIn ggplot2 you’d choose:\n\n- `geom_smooth` + explicit choices\n\nIn seaborn you might get “trend” implicitly:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport seaborn as sns\n\nsns.regplot\n```\n:::\n\n\n\n**Key skill:** identify where the “stat” happened, and how to control it.\n\n---\n\n## Practical rule\n\nWhen switching tools:\n\n- **Always ask:** “what is being computed, vs what is just being drawn?”\n- Defaults are not neutral. They encode assumptions.\n\nThis is true in *every* language.\n\n---\n\n\n## Strategy \n\n1. Rebuild your plot as a **spec**:\n   - data + mappings + marks + facets + labels\n2. Identify which library lets you keep that structure:\n   - plotnine / seaborn objects / plotly express\n3. Only drop to matplotlib / low-level plotly when you need:\n   - precise control\n   - custom annotations\n   - publication layout constraints\n\n---\n\n## What *is* a dashboard?\n\nA dashboard is:\n\n- a **layout system**\n- a **narrative**\n- a **set of components**\n- **interaction & state**\n- performance + reproducibility considerations\n\nQuarto is one way to package that.\n\n---\n\n## The transferable dashboard principles\n\nIndependent of tool:\n\n- **Hierarchy:** KPIs → key charts → detail tables\n- **Scanability:** strong titles, short annotations, whitespace\n- **Consistency:** shared scales, color semantics, typography\n- **Truthfulness:** avoid misleading encodings; show uncertainty when relevant\n- **Responsiveness:** works on laptop/projector/phone where possible\n- **User story:** “What question is this dashboard answering?”\n\n---\n\n## Quarto dashboards: what’s really happening?\n\nQuarto gives you:\n\n- Markdown narrative + code execution\n- Layout primitives\n- HTML output\n- Optional JavaScript enhancements\n\nSo: even in Quarto, you’re already building on web foundations.\n\n---\n\n## A key transfer idea: HTML + CSS + JS are the “substrate”\n\n- Quarto → renders to HTML, styled by CSS, enhanced by JS\n- Streamlit → server app that emits UI to a browser\n- Dash → React components driven by Python callbacks\n- Bokeh/Panel → interactive JS-backed plots + layouts\n\nDifferent packaging. Same substrate: **web UI**.\n\n---\n\n## Streamlit\n\n**Mental model:** write a script top-to-bottom; widgets create state; rerun on changes.\n\n- Fast to build\n- Opinionated layouts\n- Great for prototypes and internal tools\n\nTransfer from Quarto:\n\n- narrative blocks + charts + “cards”\n- parameterised reports\n\n---\n\n## Plotly Dash\n\n**Mental model:** web app with components + callbacks.\n\n- Strong for “real apps” feel\n- Scales to complex interactions\n- More engineering overhead than Streamlit\n\nTransfer from Quarto:\n\n- component layout thinking\n- explicit separation of *figure spec* and *app state*\n- concept of reactive inputs → outputs\n\n---\n\n## Bokeh\n\n**Mental model:** interactive plotting + layouts, with Python controlling JS-backed visuals.\n\n- Great for custom interactions and linked brushing\n- Panel makes dashboards simpler\n\nTransfer from Quarto:\n\n- layouts + components\n- a “document” that becomes an interactive web artifact\n\n---\n\n## When practice deviates from Quarto\n\nQuarto dashboards are often:\n\n- reproducible, report-like\n- “analysis first, UI second”\n\nPython dashboards often become:\n\n- “UI first, analysis behind”\n- live state, callbacks, caching, deployment details\n\nSkill shift:\n\n- from document author → app builder\n\nYour design principles still hold.\n\n---\n\n## Pattern 1: Cards / value boxes\n\nQuarto: “valuebox/card” expresses a KPI summary.\n\nPython equivalents:\n\n- Streamlit: `st.metric`, containers\n- Dash: HTML components + CSS\n- Panel: `pn.indicators.Number`\n\nTransfer skill:\n\n- choose the KPI\n- choose the comparison frame\n- label clearly\n\n---\n\n## Pattern 2: Tabs / pages\n\nQuarto: tabsets, multi-page sites.\n\nPython equivalents:\n\n- Streamlit pages / tabs\n- Dash multi-page routing\n- Panel tabs\n\nTransfer skill:\n\n- group by *task*, not by plot type\n- avoid “tab sprawl”\n\n---\n\n## Pattern 3: Filtering and parameters\n\nQuarto: params + code execution at render time.\n\nPython dashboards: live widgets + reactive state.\n\nTransfer skill:\n\n- decide which parameters matter\n- default to sensible values\n- show what filters are active\n- keep the interaction loop tight\n\n---\n\n## Pattern 4: JavaScript in the background\n\nEven if you never write JS:\n\n- Plotly interactivity is JS-based\n- Dash is React-based\n- Bokeh renders JS\n- Quarto widgets embed JS\n\nTransfer skill:\n\n- think in “events”\n- think in “state”\n- think in “latency”\n\n---\n\n## A robust workflow that transfers\n\n1. Start in the tidy data mindset:\n   - one row per observational unit\n   - clear variable names, types, and units\n2. Write the plot spec in words:\n   - “Scatter of X vs Y, colored by group, faceted by sex…”\n3. Implement in your target tool:\n   - choose grammar-aligned libraries first\n4. Audit:\n   - scales, legends, missing values, overplotting, uncertainty\n5. Only then polish:\n   - theme/template, annotation, typography, layout\n\n---\n\n## What to learn next\n\nIf you want the *closest* transfer from ggplot2:\n\n- **plotnine** for the syntax transfer\n- **plotly express** for rapid interactive specs\n- **seaborn objects** to keep a grammar-ish style\n\nThen add:\n\n- **matplotlib** for deeper control and “understanding the engine”\n\n---\n\n\n# Wrap-up\n\n## What you should walk away believing\n\n- Your ggplot2 skills are **not tied to R**\n- The grammar of graphics is a **portable way of thinking**\n- Python differs mostly in **how explicitly** it exposes the layers\n- Dashboards transfer via:\n  - layout thinking\n  - narrative hierarchy\n  - state/interaction design\n  - web substrate awareness\n\nNext time you meet a new tool: rebuild your plot as layers, then map.\n\n\n",
    "supporting": [
      "transferrability_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}